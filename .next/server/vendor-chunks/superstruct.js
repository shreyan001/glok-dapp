/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/superstruct";
exports.ids = ["vendor-chunks/superstruct"];
exports.modules = {

/***/ "(ssr)/./node_modules/superstruct/dist/index.cjs":
/*!*************************************************!*\
  !*** ./node_modules/superstruct/dist/index.cjs ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("(function (global, factory) {\n     true ? factory(exports) :\n    0;\n})(this, (function (exports) { 'use strict';\n\n    /**\n     * A `StructFailure` represents a single specific failure in validation.\n     */\n    /**\n     * `StructError` objects are thrown (or returned) when validation fails.\n     *\n     * Validation logic is design to exit early for maximum performance. The error\n     * represents the first error encountered during validation. For more detail,\n     * the `error.failures` property is a generator function that can be run to\n     * continue validation and receive all the failures in the data.\n     */\n    class StructError extends TypeError {\n        constructor(failure, failures) {\n            let cached;\n            const { message, explanation, ...rest } = failure;\n            const { path } = failure;\n            const msg = path.length === 0 ? message : `At path: ${path.join('.')} -- ${message}`;\n            super(explanation ?? msg);\n            if (explanation != null)\n                this.cause = msg;\n            Object.assign(this, rest);\n            this.name = this.constructor.name;\n            this.failures = () => {\n                return (cached ?? (cached = [failure, ...failures()]));\n            };\n        }\n    }\n\n    /**\n     * Check if a value is an iterator.\n     */\n    function isIterable(x) {\n        return isObject(x) && typeof x[Symbol.iterator] === 'function';\n    }\n    /**\n     * Check if a value is a plain object.\n     */\n    function isObject(x) {\n        return typeof x === 'object' && x != null;\n    }\n    /**\n     * Check if a value is a plain object.\n     */\n    function isPlainObject(x) {\n        if (Object.prototype.toString.call(x) !== '[object Object]') {\n            return false;\n        }\n        const prototype = Object.getPrototypeOf(x);\n        return prototype === null || prototype === Object.prototype;\n    }\n    /**\n     * Return a value as a printable string.\n     */\n    function print(value) {\n        if (typeof value === 'symbol') {\n            return value.toString();\n        }\n        return typeof value === 'string' ? JSON.stringify(value) : `${value}`;\n    }\n    /**\n     * Shifts (removes and returns) the first value from the `input` iterator.\n     * Like `Array.prototype.shift()` but for an `Iterator`.\n     */\n    function shiftIterator(input) {\n        const { done, value } = input.next();\n        return done ? undefined : value;\n    }\n    /**\n     * Convert a single validation result to a failure.\n     */\n    function toFailure(result, context, struct, value) {\n        if (result === true) {\n            return;\n        }\n        else if (result === false) {\n            result = {};\n        }\n        else if (typeof result === 'string') {\n            result = { message: result };\n        }\n        const { path, branch } = context;\n        const { type } = struct;\n        const { refinement, message = `Expected a value of type \\`${type}\\`${refinement ? ` with refinement \\`${refinement}\\`` : ''}, but received: \\`${print(value)}\\``, } = result;\n        return {\n            value,\n            type,\n            refinement,\n            key: path[path.length - 1],\n            path,\n            branch,\n            ...result,\n            message,\n        };\n    }\n    /**\n     * Convert a validation result to an iterable of failures.\n     */\n    function* toFailures(result, context, struct, value) {\n        if (!isIterable(result)) {\n            result = [result];\n        }\n        for (const r of result) {\n            const failure = toFailure(r, context, struct, value);\n            if (failure) {\n                yield failure;\n            }\n        }\n    }\n    /**\n     * Check a value against a struct, traversing deeply into nested values, and\n     * returning an iterator of failures or success.\n     */\n    function* run(value, struct, options = {}) {\n        const { path = [], branch = [value], coerce = false, mask = false } = options;\n        const ctx = { path, branch };\n        if (coerce) {\n            value = struct.coercer(value, ctx);\n            if (mask &&\n                struct.type !== 'type' &&\n                isObject(struct.schema) &&\n                isObject(value) &&\n                !Array.isArray(value)) {\n                for (const key in value) {\n                    if (struct.schema[key] === undefined) {\n                        delete value[key];\n                    }\n                }\n            }\n        }\n        let status = 'valid';\n        for (const failure of struct.validator(value, ctx)) {\n            failure.explanation = options.message;\n            status = 'not_valid';\n            yield [failure, undefined];\n        }\n        for (let [k, v, s] of struct.entries(value, ctx)) {\n            const ts = run(v, s, {\n                path: k === undefined ? path : [...path, k],\n                branch: k === undefined ? branch : [...branch, v],\n                coerce,\n                mask,\n                message: options.message,\n            });\n            for (const t of ts) {\n                if (t[0]) {\n                    status = t[0].refinement != null ? 'not_refined' : 'not_valid';\n                    yield [t[0], undefined];\n                }\n                else if (coerce) {\n                    v = t[1];\n                    if (k === undefined) {\n                        value = v;\n                    }\n                    else if (value instanceof Map) {\n                        value.set(k, v);\n                    }\n                    else if (value instanceof Set) {\n                        value.add(v);\n                    }\n                    else if (isObject(value)) {\n                        if (v !== undefined || k in value)\n                            value[k] = v;\n                    }\n                }\n            }\n        }\n        if (status !== 'not_valid') {\n            for (const failure of struct.refiner(value, ctx)) {\n                failure.explanation = options.message;\n                status = 'not_refined';\n                yield [failure, undefined];\n            }\n        }\n        if (status === 'valid') {\n            yield [undefined, value];\n        }\n    }\n\n    /**\n     * `Struct` objects encapsulate the validation logic for a specific type of\n     * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n     * validate unknown input data against the struct.\n     */\n    class Struct {\n        constructor(props) {\n            const { type, schema, validator, refiner, coercer = (value) => value, entries = function* () { }, } = props;\n            this.type = type;\n            this.schema = schema;\n            this.entries = entries;\n            this.coercer = coercer;\n            if (validator) {\n                this.validator = (value, context) => {\n                    const result = validator(value, context);\n                    return toFailures(result, context, this, value);\n                };\n            }\n            else {\n                this.validator = () => [];\n            }\n            if (refiner) {\n                this.refiner = (value, context) => {\n                    const result = refiner(value, context);\n                    return toFailures(result, context, this, value);\n                };\n            }\n            else {\n                this.refiner = () => [];\n            }\n        }\n        /**\n         * Assert that a value passes the struct's validation, throwing if it doesn't.\n         */\n        assert(value, message) {\n            return assert(value, this, message);\n        }\n        /**\n         * Create a value with the struct's coercion logic, then validate it.\n         */\n        create(value, message) {\n            return create(value, this, message);\n        }\n        /**\n         * Check if a value passes the struct's validation.\n         */\n        is(value) {\n            return is(value, this);\n        }\n        /**\n         * Mask a value, coercing and validating it, but returning only the subset of\n         * properties defined by the struct's schema.\n         */\n        mask(value, message) {\n            return mask(value, this, message);\n        }\n        /**\n         * Validate a value with the struct's validation logic, returning a tuple\n         * representing the result.\n         *\n         * You may optionally pass `true` for the `withCoercion` argument to coerce\n         * the value before attempting to validate it. If you do, the result will\n         * contain the coerced result when successful.\n         */\n        validate(value, options = {}) {\n            return validate(value, this, options);\n        }\n    }\n    /**\n     * Assert that a value passes a struct, throwing if it doesn't.\n     */\n    function assert(value, struct, message) {\n        const result = validate(value, struct, { message });\n        if (result[0]) {\n            throw result[0];\n        }\n    }\n    /**\n     * Create a value with the coercion logic of struct and validate it.\n     */\n    function create(value, struct, message) {\n        const result = validate(value, struct, { coerce: true, message });\n        if (result[0]) {\n            throw result[0];\n        }\n        else {\n            return result[1];\n        }\n    }\n    /**\n     * Mask a value, returning only the subset of properties defined by a struct.\n     */\n    function mask(value, struct, message) {\n        const result = validate(value, struct, { coerce: true, mask: true, message });\n        if (result[0]) {\n            throw result[0];\n        }\n        else {\n            return result[1];\n        }\n    }\n    /**\n     * Check if a value passes a struct.\n     */\n    function is(value, struct) {\n        const result = validate(value, struct);\n        return !result[0];\n    }\n    /**\n     * Validate a value against a struct, returning an error if invalid, or the\n     * value (with potential coercion) if valid.\n     */\n    function validate(value, struct, options = {}) {\n        const tuples = run(value, struct, options);\n        const tuple = shiftIterator(tuples);\n        if (tuple[0]) {\n            const error = new StructError(tuple[0], function* () {\n                for (const t of tuples) {\n                    if (t[0]) {\n                        yield t[0];\n                    }\n                }\n            });\n            return [error, undefined];\n        }\n        else {\n            const v = tuple[1];\n            return [undefined, v];\n        }\n    }\n\n    function assign(...Structs) {\n        const isType = Structs[0].type === 'type';\n        const schemas = Structs.map((s) => s.schema);\n        const schema = Object.assign({}, ...schemas);\n        return isType ? type(schema) : object(schema);\n    }\n    /**\n     * Define a new struct type with a custom validation function.\n     */\n    function define(name, validator) {\n        return new Struct({ type: name, schema: null, validator });\n    }\n    /**\n     * Create a new struct based on an existing struct, but the value is allowed to\n     * be `undefined`. `log` will be called if the value is not `undefined`.\n     */\n    function deprecated(struct, log) {\n        return new Struct({\n            ...struct,\n            refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n            validator(value, ctx) {\n                if (value === undefined) {\n                    return true;\n                }\n                else {\n                    log(value, ctx);\n                    return struct.validator(value, ctx);\n                }\n            },\n        });\n    }\n    /**\n     * Create a struct with dynamic validation logic.\n     *\n     * The callback will receive the value currently being validated, and must\n     * return a struct object to validate it with. This can be useful to model\n     * validation logic that changes based on its input.\n     */\n    function dynamic(fn) {\n        return new Struct({\n            type: 'dynamic',\n            schema: null,\n            *entries(value, ctx) {\n                const struct = fn(value, ctx);\n                yield* struct.entries(value, ctx);\n            },\n            validator(value, ctx) {\n                const struct = fn(value, ctx);\n                return struct.validator(value, ctx);\n            },\n            coercer(value, ctx) {\n                const struct = fn(value, ctx);\n                return struct.coercer(value, ctx);\n            },\n            refiner(value, ctx) {\n                const struct = fn(value, ctx);\n                return struct.refiner(value, ctx);\n            },\n        });\n    }\n    /**\n     * Create a struct with lazily evaluated validation logic.\n     *\n     * The first time validation is run with the struct, the callback will be called\n     * and must return a struct object to use. This is useful for cases where you\n     * want to have self-referential structs for nested data structures to avoid a\n     * circular definition problem.\n     */\n    function lazy(fn) {\n        let struct;\n        return new Struct({\n            type: 'lazy',\n            schema: null,\n            *entries(value, ctx) {\n                struct ?? (struct = fn());\n                yield* struct.entries(value, ctx);\n            },\n            validator(value, ctx) {\n                struct ?? (struct = fn());\n                return struct.validator(value, ctx);\n            },\n            coercer(value, ctx) {\n                struct ?? (struct = fn());\n                return struct.coercer(value, ctx);\n            },\n            refiner(value, ctx) {\n                struct ?? (struct = fn());\n                return struct.refiner(value, ctx);\n            },\n        });\n    }\n    /**\n     * Create a new struct based on an existing object struct, but excluding\n     * specific properties.\n     *\n     * Like TypeScript's `Omit` utility.\n     */\n    function omit(struct, keys) {\n        const { schema } = struct;\n        const subschema = { ...schema };\n        for (const key of keys) {\n            delete subschema[key];\n        }\n        switch (struct.type) {\n            case 'type':\n                return type(subschema);\n            default:\n                return object(subschema);\n        }\n    }\n    /**\n     * Create a new struct based on an existing object struct, but with all of its\n     * properties allowed to be `undefined`.\n     *\n     * Like TypeScript's `Partial` utility.\n     */\n    function partial(struct) {\n        const isStruct = struct instanceof Struct;\n        const schema = isStruct ? { ...struct.schema } : { ...struct };\n        for (const key in schema) {\n            schema[key] = optional(schema[key]);\n        }\n        if (isStruct && struct.type === 'type') {\n            return type(schema);\n        }\n        return object(schema);\n    }\n    /**\n     * Create a new struct based on an existing object struct, but only including\n     * specific properties.\n     *\n     * Like TypeScript's `Pick` utility.\n     */\n    function pick(struct, keys) {\n        const { schema } = struct;\n        const subschema = {};\n        for (const key of keys) {\n            subschema[key] = schema[key];\n        }\n        switch (struct.type) {\n            case 'type':\n                return type(subschema);\n            default:\n                return object(subschema);\n        }\n    }\n    /**\n     * Define a new struct type with a custom validation function.\n     *\n     * @deprecated This function has been renamed to `define`.\n     */\n    function struct(name, validator) {\n        console.warn('superstruct@0.11 - The `struct` helper has been renamed to `define`.');\n        return define(name, validator);\n    }\n\n    /**\n     * Ensure that any value passes validation.\n     */\n    function any() {\n        return define('any', () => true);\n    }\n    function array(Element) {\n        return new Struct({\n            type: 'array',\n            schema: Element,\n            *entries(value) {\n                if (Element && Array.isArray(value)) {\n                    for (const [i, v] of value.entries()) {\n                        yield [i, v, Element];\n                    }\n                }\n            },\n            coercer(value) {\n                return Array.isArray(value) ? value.slice() : value;\n            },\n            validator(value) {\n                return (Array.isArray(value) ||\n                    `Expected an array value, but received: ${print(value)}`);\n            },\n        });\n    }\n    /**\n     * Ensure that a value is a bigint.\n     */\n    function bigint() {\n        return define('bigint', (value) => {\n            return typeof value === 'bigint';\n        });\n    }\n    /**\n     * Ensure that a value is a boolean.\n     */\n    function boolean() {\n        return define('boolean', (value) => {\n            return typeof value === 'boolean';\n        });\n    }\n    /**\n     * Ensure that a value is a valid `Date`.\n     *\n     * Note: this also ensures that the value is *not* an invalid `Date` object,\n     * which can occur when parsing a date fails but still returns a `Date`.\n     */\n    function date() {\n        return define('date', (value) => {\n            return ((value instanceof Date && !isNaN(value.getTime())) ||\n                `Expected a valid \\`Date\\` object, but received: ${print(value)}`);\n        });\n    }\n    function enums(values) {\n        const schema = {};\n        const description = values.map((v) => print(v)).join();\n        for (const key of values) {\n            schema[key] = key;\n        }\n        return new Struct({\n            type: 'enums',\n            schema,\n            validator(value) {\n                return (values.includes(value) ||\n                    `Expected one of \\`${description}\\`, but received: ${print(value)}`);\n            },\n        });\n    }\n    /**\n     * Ensure that a value is a function.\n     */\n    function func() {\n        return define('func', (value) => {\n            return (typeof value === 'function' ||\n                `Expected a function, but received: ${print(value)}`);\n        });\n    }\n    /**\n     * Ensure that a value is an instance of a specific class.\n     */\n    function instance(Class) {\n        return define('instance', (value) => {\n            return (value instanceof Class ||\n                `Expected a \\`${Class.name}\\` instance, but received: ${print(value)}`);\n        });\n    }\n    /**\n     * Ensure that a value is an integer.\n     */\n    function integer() {\n        return define('integer', (value) => {\n            return ((typeof value === 'number' && !isNaN(value) && Number.isInteger(value)) ||\n                `Expected an integer, but received: ${print(value)}`);\n        });\n    }\n    /**\n     * Ensure that a value matches all of a set of types.\n     */\n    function intersection(Structs) {\n        return new Struct({\n            type: 'intersection',\n            schema: null,\n            *entries(value, ctx) {\n                for (const S of Structs) {\n                    yield* S.entries(value, ctx);\n                }\n            },\n            *validator(value, ctx) {\n                for (const S of Structs) {\n                    yield* S.validator(value, ctx);\n                }\n            },\n            *refiner(value, ctx) {\n                for (const S of Structs) {\n                    yield* S.refiner(value, ctx);\n                }\n            },\n        });\n    }\n    function literal(constant) {\n        const description = print(constant);\n        const t = typeof constant;\n        return new Struct({\n            type: 'literal',\n            schema: t === 'string' || t === 'number' || t === 'boolean' ? constant : null,\n            validator(value) {\n                return (value === constant ||\n                    `Expected the literal \\`${description}\\`, but received: ${print(value)}`);\n            },\n        });\n    }\n    function map(Key, Value) {\n        return new Struct({\n            type: 'map',\n            schema: null,\n            *entries(value) {\n                if (Key && Value && value instanceof Map) {\n                    for (const [k, v] of value.entries()) {\n                        yield [k, k, Key];\n                        yield [k, v, Value];\n                    }\n                }\n            },\n            coercer(value) {\n                return value instanceof Map ? new Map(value) : value;\n            },\n            validator(value) {\n                return (value instanceof Map ||\n                    `Expected a \\`Map\\` object, but received: ${print(value)}`);\n            },\n        });\n    }\n    /**\n     * Ensure that no value ever passes validation.\n     */\n    function never() {\n        return define('never', () => false);\n    }\n    /**\n     * Augment an existing struct to allow `null` values.\n     */\n    function nullable(struct) {\n        return new Struct({\n            ...struct,\n            validator: (value, ctx) => value === null || struct.validator(value, ctx),\n            refiner: (value, ctx) => value === null || struct.refiner(value, ctx),\n        });\n    }\n    /**\n     * Ensure that a value is a number.\n     */\n    function number() {\n        return define('number', (value) => {\n            return ((typeof value === 'number' && !isNaN(value)) ||\n                `Expected a number, but received: ${print(value)}`);\n        });\n    }\n    function object(schema) {\n        const knowns = schema ? Object.keys(schema) : [];\n        const Never = never();\n        return new Struct({\n            type: 'object',\n            schema: schema ? schema : null,\n            *entries(value) {\n                if (schema && isObject(value)) {\n                    const unknowns = new Set(Object.keys(value));\n                    for (const key of knowns) {\n                        unknowns.delete(key);\n                        yield [key, value[key], schema[key]];\n                    }\n                    for (const key of unknowns) {\n                        yield [key, value[key], Never];\n                    }\n                }\n            },\n            validator(value) {\n                return (isObject(value) || `Expected an object, but received: ${print(value)}`);\n            },\n            coercer(value) {\n                return isObject(value) ? { ...value } : value;\n            },\n        });\n    }\n    /**\n     * Augment a struct to allow `undefined` values.\n     */\n    function optional(struct) {\n        return new Struct({\n            ...struct,\n            validator: (value, ctx) => value === undefined || struct.validator(value, ctx),\n            refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n        });\n    }\n    /**\n     * Ensure that a value is an object with keys and values of specific types, but\n     * without ensuring any specific shape of properties.\n     *\n     * Like TypeScript's `Record` utility.\n     */\n    function record(Key, Value) {\n        return new Struct({\n            type: 'record',\n            schema: null,\n            *entries(value) {\n                if (isObject(value)) {\n                    for (const k in value) {\n                        const v = value[k];\n                        yield [k, k, Key];\n                        yield [k, v, Value];\n                    }\n                }\n            },\n            validator(value) {\n                return (isObject(value) || `Expected an object, but received: ${print(value)}`);\n            },\n        });\n    }\n    /**\n     * Ensure that a value is a `RegExp`.\n     *\n     * Note: this does not test the value against the regular expression! For that\n     * you need to use the `pattern()` refinement.\n     */\n    function regexp() {\n        return define('regexp', (value) => {\n            return value instanceof RegExp;\n        });\n    }\n    function set(Element) {\n        return new Struct({\n            type: 'set',\n            schema: null,\n            *entries(value) {\n                if (Element && value instanceof Set) {\n                    for (const v of value) {\n                        yield [v, v, Element];\n                    }\n                }\n            },\n            coercer(value) {\n                return value instanceof Set ? new Set(value) : value;\n            },\n            validator(value) {\n                return (value instanceof Set ||\n                    `Expected a \\`Set\\` object, but received: ${print(value)}`);\n            },\n        });\n    }\n    /**\n     * Ensure that a value is a string.\n     */\n    function string() {\n        return define('string', (value) => {\n            return (typeof value === 'string' ||\n                `Expected a string, but received: ${print(value)}`);\n        });\n    }\n    /**\n     * Ensure that a value is a tuple of a specific length, and that each of its\n     * elements is of a specific type.\n     */\n    function tuple(Structs) {\n        const Never = never();\n        return new Struct({\n            type: 'tuple',\n            schema: null,\n            *entries(value) {\n                if (Array.isArray(value)) {\n                    const length = Math.max(Structs.length, value.length);\n                    for (let i = 0; i < length; i++) {\n                        yield [i, value[i], Structs[i] || Never];\n                    }\n                }\n            },\n            validator(value) {\n                return (Array.isArray(value) ||\n                    `Expected an array, but received: ${print(value)}`);\n            },\n        });\n    }\n    /**\n     * Ensure that a value has a set of known properties of specific types.\n     *\n     * Note: Unrecognized properties are allowed and untouched. This is similar to\n     * how TypeScript's structural typing works.\n     */\n    function type(schema) {\n        const keys = Object.keys(schema);\n        return new Struct({\n            type: 'type',\n            schema,\n            *entries(value) {\n                if (isObject(value)) {\n                    for (const k of keys) {\n                        yield [k, value[k], schema[k]];\n                    }\n                }\n            },\n            validator(value) {\n                return (isObject(value) || `Expected an object, but received: ${print(value)}`);\n            },\n            coercer(value) {\n                return isObject(value) ? { ...value } : value;\n            },\n        });\n    }\n    /**\n     * Ensure that a value matches one of a set of types.\n     */\n    function union(Structs) {\n        const description = Structs.map((s) => s.type).join(' | ');\n        return new Struct({\n            type: 'union',\n            schema: null,\n            coercer(value) {\n                for (const S of Structs) {\n                    const [error, coerced] = S.validate(value, { coerce: true });\n                    if (!error) {\n                        return coerced;\n                    }\n                }\n                return value;\n            },\n            validator(value, ctx) {\n                const failures = [];\n                for (const S of Structs) {\n                    const [...tuples] = run(value, S, ctx);\n                    const [first] = tuples;\n                    if (!first[0]) {\n                        return [];\n                    }\n                    else {\n                        for (const [failure] of tuples) {\n                            if (failure) {\n                                failures.push(failure);\n                            }\n                        }\n                    }\n                }\n                return [\n                    `Expected the value to satisfy a union of \\`${description}\\`, but received: ${print(value)}`,\n                    ...failures,\n                ];\n            },\n        });\n    }\n    /**\n     * Ensure that any value passes validation, without widening its type to `any`.\n     */\n    function unknown() {\n        return define('unknown', () => true);\n    }\n\n    /**\n     * Augment a `Struct` to add an additional coercion step to its input.\n     *\n     * This allows you to transform input data before validating it, to increase the\n     * likelihood that it passes validationâ€”for example for default values, parsing\n     * different formats, etc.\n     *\n     * Note: You must use `create(value, Struct)` on the value to have the coercion\n     * take effect! Using simply `assert()` or `is()` will not use coercion.\n     */\n    function coerce(struct, condition, coercer) {\n        return new Struct({\n            ...struct,\n            coercer: (value, ctx) => {\n                return is(value, condition)\n                    ? struct.coercer(coercer(value, ctx), ctx)\n                    : struct.coercer(value, ctx);\n            },\n        });\n    }\n    /**\n     * Augment a struct to replace `undefined` values with a default.\n     *\n     * Note: You must use `create(value, Struct)` on the value to have the coercion\n     * take effect! Using simply `assert()` or `is()` will not use coercion.\n     */\n    function defaulted(struct, fallback, options = {}) {\n        return coerce(struct, unknown(), (x) => {\n            const f = typeof fallback === 'function' ? fallback() : fallback;\n            if (x === undefined) {\n                return f;\n            }\n            if (!options.strict && isPlainObject(x) && isPlainObject(f)) {\n                const ret = { ...x };\n                let changed = false;\n                for (const key in f) {\n                    if (ret[key] === undefined) {\n                        ret[key] = f[key];\n                        changed = true;\n                    }\n                }\n                if (changed) {\n                    return ret;\n                }\n            }\n            return x;\n        });\n    }\n    /**\n     * Augment a struct to trim string inputs.\n     *\n     * Note: You must use `create(value, Struct)` on the value to have the coercion\n     * take effect! Using simply `assert()` or `is()` will not use coercion.\n     */\n    function trimmed(struct) {\n        return coerce(struct, string(), (x) => x.trim());\n    }\n\n    /**\n     * Ensure that a string, array, map, or set is empty.\n     */\n    function empty(struct) {\n        return refine(struct, 'empty', (value) => {\n            const size = getSize(value);\n            return (size === 0 ||\n                `Expected an empty ${struct.type} but received one with a size of \\`${size}\\``);\n        });\n    }\n    function getSize(value) {\n        if (value instanceof Map || value instanceof Set) {\n            return value.size;\n        }\n        else {\n            return value.length;\n        }\n    }\n    /**\n     * Ensure that a number or date is below a threshold.\n     */\n    function max(struct, threshold, options = {}) {\n        const { exclusive } = options;\n        return refine(struct, 'max', (value) => {\n            return exclusive\n                ? value < threshold\n                : value <= threshold ||\n                    `Expected a ${struct.type} less than ${exclusive ? '' : 'or equal to '}${threshold} but received \\`${value}\\``;\n        });\n    }\n    /**\n     * Ensure that a number or date is above a threshold.\n     */\n    function min(struct, threshold, options = {}) {\n        const { exclusive } = options;\n        return refine(struct, 'min', (value) => {\n            return exclusive\n                ? value > threshold\n                : value >= threshold ||\n                    `Expected a ${struct.type} greater than ${exclusive ? '' : 'or equal to '}${threshold} but received \\`${value}\\``;\n        });\n    }\n    /**\n     * Ensure that a string, array, map or set is not empty.\n     */\n    function nonempty(struct) {\n        return refine(struct, 'nonempty', (value) => {\n            const size = getSize(value);\n            return (size > 0 || `Expected a nonempty ${struct.type} but received an empty one`);\n        });\n    }\n    /**\n     * Ensure that a string matches a regular expression.\n     */\n    function pattern(struct, regexp) {\n        return refine(struct, 'pattern', (value) => {\n            return (regexp.test(value) ||\n                `Expected a ${struct.type} matching \\`/${regexp.source}/\\` but received \"${value}\"`);\n        });\n    }\n    /**\n     * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.\n     */\n    function size(struct, min, max = min) {\n        const expected = `Expected a ${struct.type}`;\n        const of = min === max ? `of \\`${min}\\`` : `between \\`${min}\\` and \\`${max}\\``;\n        return refine(struct, 'size', (value) => {\n            if (typeof value === 'number' || value instanceof Date) {\n                return ((min <= value && value <= max) ||\n                    `${expected} ${of} but received \\`${value}\\``);\n            }\n            else if (value instanceof Map || value instanceof Set) {\n                const { size } = value;\n                return ((min <= size && size <= max) ||\n                    `${expected} with a size ${of} but received one with a size of \\`${size}\\``);\n            }\n            else {\n                const { length } = value;\n                return ((min <= length && length <= max) ||\n                    `${expected} with a length ${of} but received one with a length of \\`${length}\\``);\n            }\n        });\n    }\n    /**\n     * Augment a `Struct` to add an additional refinement to the validation.\n     *\n     * The refiner function is guaranteed to receive a value of the struct's type,\n     * because the struct's existing validation will already have passed. This\n     * allows you to layer additional validation on top of existing structs.\n     */\n    function refine(struct, name, refiner) {\n        return new Struct({\n            ...struct,\n            *refiner(value, ctx) {\n                yield* struct.refiner(value, ctx);\n                const result = refiner(value, ctx);\n                const failures = toFailures(result, ctx, struct, value);\n                for (const failure of failures) {\n                    yield { ...failure, refinement: name };\n                }\n            },\n        });\n    }\n\n    exports.Struct = Struct;\n    exports.StructError = StructError;\n    exports.any = any;\n    exports.array = array;\n    exports.assert = assert;\n    exports.assign = assign;\n    exports.bigint = bigint;\n    exports.boolean = boolean;\n    exports.coerce = coerce;\n    exports.create = create;\n    exports.date = date;\n    exports.defaulted = defaulted;\n    exports.define = define;\n    exports.deprecated = deprecated;\n    exports.dynamic = dynamic;\n    exports.empty = empty;\n    exports.enums = enums;\n    exports.func = func;\n    exports.instance = instance;\n    exports.integer = integer;\n    exports.intersection = intersection;\n    exports.is = is;\n    exports.lazy = lazy;\n    exports.literal = literal;\n    exports.map = map;\n    exports.mask = mask;\n    exports.max = max;\n    exports.min = min;\n    exports.never = never;\n    exports.nonempty = nonempty;\n    exports.nullable = nullable;\n    exports.number = number;\n    exports.object = object;\n    exports.omit = omit;\n    exports.optional = optional;\n    exports.partial = partial;\n    exports.pattern = pattern;\n    exports.pick = pick;\n    exports.record = record;\n    exports.refine = refine;\n    exports.regexp = regexp;\n    exports.set = set;\n    exports.size = size;\n    exports.string = string;\n    exports.struct = struct;\n    exports.trimmed = trimmed;\n    exports.tuple = tuple;\n    exports.type = type;\n    exports.union = union;\n    exports.unknown = unknown;\n    exports.validate = validate;\n\n}));\n//# sourceMappingURL=index.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3VwZXJzdHJ1Y3QvZGlzdC9pbmRleC5janMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxJQUFJLEtBQTREO0FBQ2hFLElBQUksQ0FDNEc7QUFDaEgsQ0FBQyw4QkFBOEI7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0NBQWdDO0FBQ3BELG9CQUFvQixPQUFPO0FBQzNCLGtFQUFrRSxnQkFBZ0IsS0FBSyxRQUFRO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsTUFBTTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLGdCQUFnQixlQUFlO0FBQy9CLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixvREFBb0QsS0FBSyxJQUFJLG1DQUFtQyxXQUFXLFNBQVMsb0JBQW9CLGFBQWEsT0FBTztBQUM1SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDLGdCQUFnQiw0REFBNEQ7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QU87QUFDL0I7QUFDQSx1QkFBdUIsVUFBVSxjQUFjLElBQUksb0NBQW9DLEtBQUs7QUFDNUY7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0EsdUJBQXVCLFVBQVUsZ0JBQWdCLElBQUksc0NBQXNDLE9BQU87QUFDbEc7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYW5nY2hhaW4tbmV4dGpzLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3N1cGVyc3RydWN0L2Rpc3QvaW5kZXguY2pzP2RjYTUiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5TdXBlcnN0cnVjdCA9IHt9KSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyoqXG4gICAgICogQSBgU3RydWN0RmFpbHVyZWAgcmVwcmVzZW50cyBhIHNpbmdsZSBzcGVjaWZpYyBmYWlsdXJlIGluIHZhbGlkYXRpb24uXG4gICAgICovXG4gICAgLyoqXG4gICAgICogYFN0cnVjdEVycm9yYCBvYmplY3RzIGFyZSB0aHJvd24gKG9yIHJldHVybmVkKSB3aGVuIHZhbGlkYXRpb24gZmFpbHMuXG4gICAgICpcbiAgICAgKiBWYWxpZGF0aW9uIGxvZ2ljIGlzIGRlc2lnbiB0byBleGl0IGVhcmx5IGZvciBtYXhpbXVtIHBlcmZvcm1hbmNlLiBUaGUgZXJyb3JcbiAgICAgKiByZXByZXNlbnRzIHRoZSBmaXJzdCBlcnJvciBlbmNvdW50ZXJlZCBkdXJpbmcgdmFsaWRhdGlvbi4gRm9yIG1vcmUgZGV0YWlsLFxuICAgICAqIHRoZSBgZXJyb3IuZmFpbHVyZXNgIHByb3BlcnR5IGlzIGEgZ2VuZXJhdG9yIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHJ1biB0b1xuICAgICAqIGNvbnRpbnVlIHZhbGlkYXRpb24gYW5kIHJlY2VpdmUgYWxsIHRoZSBmYWlsdXJlcyBpbiB0aGUgZGF0YS5cbiAgICAgKi9cbiAgICBjbGFzcyBTdHJ1Y3RFcnJvciBleHRlbmRzIFR5cGVFcnJvciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGZhaWx1cmUsIGZhaWx1cmVzKSB7XG4gICAgICAgICAgICBsZXQgY2FjaGVkO1xuICAgICAgICAgICAgY29uc3QgeyBtZXNzYWdlLCBleHBsYW5hdGlvbiwgLi4ucmVzdCB9ID0gZmFpbHVyZTtcbiAgICAgICAgICAgIGNvbnN0IHsgcGF0aCB9ID0gZmFpbHVyZTtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IHBhdGgubGVuZ3RoID09PSAwID8gbWVzc2FnZSA6IGBBdCBwYXRoOiAke3BhdGguam9pbignLicpfSAtLSAke21lc3NhZ2V9YDtcbiAgICAgICAgICAgIHN1cGVyKGV4cGxhbmF0aW9uID8/IG1zZyk7XG4gICAgICAgICAgICBpZiAoZXhwbGFuYXRpb24gIT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzLmNhdXNlID0gbXNnO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCByZXN0KTtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgICAgIHRoaXMuZmFpbHVyZXMgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChjYWNoZWQgPz8gKGNhY2hlZCA9IFtmYWlsdXJlLCAuLi5mYWlsdXJlcygpXSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYW4gaXRlcmF0b3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJdGVyYWJsZSh4KSB7XG4gICAgICAgIHJldHVybiBpc09iamVjdCh4KSAmJiB0eXBlb2YgeFtTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KHgpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBwbGFpbiBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh4KSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgIT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHgpO1xuICAgICAgICByZXR1cm4gcHJvdG90eXBlID09PSBudWxsIHx8IHByb3RvdHlwZSA9PT0gT2JqZWN0LnByb3RvdHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgdmFsdWUgYXMgYSBwcmludGFibGUgc3RyaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByaW50KHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IEpTT04uc3RyaW5naWZ5KHZhbHVlKSA6IGAke3ZhbHVlfWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNoaWZ0cyAocmVtb3ZlcyBhbmQgcmV0dXJucykgdGhlIGZpcnN0IHZhbHVlIGZyb20gdGhlIGBpbnB1dGAgaXRlcmF0b3IuXG4gICAgICogTGlrZSBgQXJyYXkucHJvdG90eXBlLnNoaWZ0KClgIGJ1dCBmb3IgYW4gYEl0ZXJhdG9yYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaGlmdEl0ZXJhdG9yKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGlucHV0Lm5leHQoKTtcbiAgICAgICAgcmV0dXJuIGRvbmUgPyB1bmRlZmluZWQgOiB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCBhIHNpbmdsZSB2YWxpZGF0aW9uIHJlc3VsdCB0byBhIGZhaWx1cmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9GYWlsdXJlKHJlc3VsdCwgY29udGV4dCwgc3RydWN0LCB2YWx1ZSkge1xuICAgICAgICBpZiAocmVzdWx0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmVzdWx0ID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHsgbWVzc2FnZTogcmVzdWx0IH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBwYXRoLCBicmFuY2ggfSA9IGNvbnRleHQ7XG4gICAgICAgIGNvbnN0IHsgdHlwZSB9ID0gc3RydWN0O1xuICAgICAgICBjb25zdCB7IHJlZmluZW1lbnQsIG1lc3NhZ2UgPSBgRXhwZWN0ZWQgYSB2YWx1ZSBvZiB0eXBlIFxcYCR7dHlwZX1cXGAke3JlZmluZW1lbnQgPyBgIHdpdGggcmVmaW5lbWVudCBcXGAke3JlZmluZW1lbnR9XFxgYCA6ICcnfSwgYnV0IHJlY2VpdmVkOiBcXGAke3ByaW50KHZhbHVlKX1cXGBgLCB9ID0gcmVzdWx0O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgcmVmaW5lbWVudCxcbiAgICAgICAgICAgIGtleTogcGF0aFtwYXRoLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIGJyYW5jaCxcbiAgICAgICAgICAgIC4uLnJlc3VsdCxcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSB2YWxpZGF0aW9uIHJlc3VsdCB0byBhbiBpdGVyYWJsZSBvZiBmYWlsdXJlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiogdG9GYWlsdXJlcyhyZXN1bHQsIGNvbnRleHQsIHN0cnVjdCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc0l0ZXJhYmxlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFtyZXN1bHRdO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgciBvZiByZXN1bHQpIHtcbiAgICAgICAgICAgIGNvbnN0IGZhaWx1cmUgPSB0b0ZhaWx1cmUociwgY29udGV4dCwgc3RydWN0LCB2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoZmFpbHVyZSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGZhaWx1cmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgYSB2YWx1ZSBhZ2FpbnN0IGEgc3RydWN0LCB0cmF2ZXJzaW5nIGRlZXBseSBpbnRvIG5lc3RlZCB2YWx1ZXMsIGFuZFxuICAgICAqIHJldHVybmluZyBhbiBpdGVyYXRvciBvZiBmYWlsdXJlcyBvciBzdWNjZXNzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uKiBydW4odmFsdWUsIHN0cnVjdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgcGF0aCA9IFtdLCBicmFuY2ggPSBbdmFsdWVdLCBjb2VyY2UgPSBmYWxzZSwgbWFzayA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBjdHggPSB7IHBhdGgsIGJyYW5jaCB9O1xuICAgICAgICBpZiAoY29lcmNlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHN0cnVjdC5jb2VyY2VyKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgaWYgKG1hc2sgJiZcbiAgICAgICAgICAgICAgICBzdHJ1Y3QudHlwZSAhPT0gJ3R5cGUnICYmXG4gICAgICAgICAgICAgICAgaXNPYmplY3Qoc3RydWN0LnNjaGVtYSkgJiZcbiAgICAgICAgICAgICAgICBpc09iamVjdCh2YWx1ZSkgJiZcbiAgICAgICAgICAgICAgICAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RydWN0LnNjaGVtYVtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBzdGF0dXMgPSAndmFsaWQnO1xuICAgICAgICBmb3IgKGNvbnN0IGZhaWx1cmUgb2Ygc3RydWN0LnZhbGlkYXRvcih2YWx1ZSwgY3R4KSkge1xuICAgICAgICAgICAgZmFpbHVyZS5leHBsYW5hdGlvbiA9IG9wdGlvbnMubWVzc2FnZTtcbiAgICAgICAgICAgIHN0YXR1cyA9ICdub3RfdmFsaWQnO1xuICAgICAgICAgICAgeWllbGQgW2ZhaWx1cmUsIHVuZGVmaW5lZF07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgW2ssIHYsIHNdIG9mIHN0cnVjdC5lbnRyaWVzKHZhbHVlLCBjdHgpKSB7XG4gICAgICAgICAgICBjb25zdCB0cyA9IHJ1bih2LCBzLCB7XG4gICAgICAgICAgICAgICAgcGF0aDogayA9PT0gdW5kZWZpbmVkID8gcGF0aCA6IFsuLi5wYXRoLCBrXSxcbiAgICAgICAgICAgICAgICBicmFuY2g6IGsgPT09IHVuZGVmaW5lZCA/IGJyYW5jaCA6IFsuLi5icmFuY2gsIHZdLFxuICAgICAgICAgICAgICAgIGNvZXJjZSxcbiAgICAgICAgICAgICAgICBtYXNrLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG9wdGlvbnMubWVzc2FnZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9yIChjb25zdCB0IG9mIHRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gdFswXS5yZWZpbmVtZW50ICE9IG51bGwgPyAnbm90X3JlZmluZWQnIDogJ25vdF92YWxpZCc7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIFt0WzBdLCB1bmRlZmluZWRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb2VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdiA9IHRbMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuc2V0KGssIHYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5hZGQodik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkIHx8IGsgaW4gdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVba10gPSB2O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0dXMgIT09ICdub3RfdmFsaWQnKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZhaWx1cmUgb2Ygc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eCkpIHtcbiAgICAgICAgICAgICAgICBmYWlsdXJlLmV4cGxhbmF0aW9uID0gb3B0aW9ucy5tZXNzYWdlO1xuICAgICAgICAgICAgICAgIHN0YXR1cyA9ICdub3RfcmVmaW5lZCc7XG4gICAgICAgICAgICAgICAgeWllbGQgW2ZhaWx1cmUsIHVuZGVmaW5lZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ3ZhbGlkJykge1xuICAgICAgICAgICAgeWllbGQgW3VuZGVmaW5lZCwgdmFsdWVdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYFN0cnVjdGAgb2JqZWN0cyBlbmNhcHN1bGF0ZSB0aGUgdmFsaWRhdGlvbiBsb2dpYyBmb3IgYSBzcGVjaWZpYyB0eXBlIG9mXG4gICAgICogdmFsdWVzLiBPbmNlIGNvbnN0cnVjdGVkLCB5b3UgdXNlIHRoZSBgYXNzZXJ0YCwgYGlzYCBvciBgdmFsaWRhdGVgIGhlbHBlcnMgdG9cbiAgICAgKiB2YWxpZGF0ZSB1bmtub3duIGlucHV0IGRhdGEgYWdhaW5zdCB0aGUgc3RydWN0LlxuICAgICAqL1xuICAgIGNsYXNzIFN0cnVjdCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgICAgICBjb25zdCB7IHR5cGUsIHNjaGVtYSwgdmFsaWRhdG9yLCByZWZpbmVyLCBjb2VyY2VyID0gKHZhbHVlKSA9PiB2YWx1ZSwgZW50cmllcyA9IGZ1bmN0aW9uKiAoKSB7IH0sIH0gPSBwcm9wcztcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgICAgIHRoaXMuZW50cmllcyA9IGVudHJpZXM7XG4gICAgICAgICAgICB0aGlzLmNvZXJjZXIgPSBjb2VyY2VyO1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRvcikge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsaWRhdG9yID0gKHZhbHVlLCBjb250ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRvcih2YWx1ZSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b0ZhaWx1cmVzKHJlc3VsdCwgY29udGV4dCwgdGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRvciA9ICgpID0+IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlZmluZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZmluZXIgPSAodmFsdWUsIGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVmaW5lcih2YWx1ZSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b0ZhaWx1cmVzKHJlc3VsdCwgY29udGV4dCwgdGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZmluZXIgPSAoKSA9PiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQXNzZXJ0IHRoYXQgYSB2YWx1ZSBwYXNzZXMgdGhlIHN0cnVjdCdzIHZhbGlkYXRpb24sIHRocm93aW5nIGlmIGl0IGRvZXNuJ3QuXG4gICAgICAgICAqL1xuICAgICAgICBhc3NlcnQodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBhc3NlcnQodmFsdWUsIHRoaXMsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSB2YWx1ZSB3aXRoIHRoZSBzdHJ1Y3QncyBjb2VyY2lvbiBsb2dpYywgdGhlbiB2YWxpZGF0ZSBpdC5cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZSh2YWx1ZSwgdGhpcywgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIGlmIGEgdmFsdWUgcGFzc2VzIHRoZSBzdHJ1Y3QncyB2YWxpZGF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgaXModmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBpcyh2YWx1ZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hc2sgYSB2YWx1ZSwgY29lcmNpbmcgYW5kIHZhbGlkYXRpbmcgaXQsIGJ1dCByZXR1cm5pbmcgb25seSB0aGUgc3Vic2V0IG9mXG4gICAgICAgICAqIHByb3BlcnRpZXMgZGVmaW5lZCBieSB0aGUgc3RydWN0J3Mgc2NoZW1hLlxuICAgICAgICAgKi9cbiAgICAgICAgbWFzayh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIG1hc2sodmFsdWUsIHRoaXMsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWYWxpZGF0ZSBhIHZhbHVlIHdpdGggdGhlIHN0cnVjdCdzIHZhbGlkYXRpb24gbG9naWMsIHJldHVybmluZyBhIHR1cGxlXG4gICAgICAgICAqIHJlcHJlc2VudGluZyB0aGUgcmVzdWx0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBZb3UgbWF5IG9wdGlvbmFsbHkgcGFzcyBgdHJ1ZWAgZm9yIHRoZSBgd2l0aENvZXJjaW9uYCBhcmd1bWVudCB0byBjb2VyY2VcbiAgICAgICAgICogdGhlIHZhbHVlIGJlZm9yZSBhdHRlbXB0aW5nIHRvIHZhbGlkYXRlIGl0LiBJZiB5b3UgZG8sIHRoZSByZXN1bHQgd2lsbFxuICAgICAgICAgKiBjb250YWluIHRoZSBjb2VyY2VkIHJlc3VsdCB3aGVuIHN1Y2Nlc3NmdWwuXG4gICAgICAgICAqL1xuICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGUodmFsdWUsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2VydCB0aGF0IGEgdmFsdWUgcGFzc2VzIGEgc3RydWN0LCB0aHJvd2luZyBpZiBpdCBkb2Vzbid0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc2VydCh2YWx1ZSwgc3RydWN0LCBtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKHZhbHVlLCBzdHJ1Y3QsIHsgbWVzc2FnZSB9KTtcbiAgICAgICAgaWYgKHJlc3VsdFswXSkge1xuICAgICAgICAgICAgdGhyb3cgcmVzdWx0WzBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHZhbHVlIHdpdGggdGhlIGNvZXJjaW9uIGxvZ2ljIG9mIHN0cnVjdCBhbmQgdmFsaWRhdGUgaXQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHZhbHVlLCBzdHJ1Y3QsIG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGUodmFsdWUsIHN0cnVjdCwgeyBjb2VyY2U6IHRydWUsIG1lc3NhZ2UgfSk7XG4gICAgICAgIGlmIChyZXN1bHRbMF0pIHtcbiAgICAgICAgICAgIHRocm93IHJlc3VsdFswXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRbMV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFzayBhIHZhbHVlLCByZXR1cm5pbmcgb25seSB0aGUgc3Vic2V0IG9mIHByb3BlcnRpZXMgZGVmaW5lZCBieSBhIHN0cnVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXNrKHZhbHVlLCBzdHJ1Y3QsIG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGUodmFsdWUsIHN0cnVjdCwgeyBjb2VyY2U6IHRydWUsIG1hc2s6IHRydWUsIG1lc3NhZ2UgfSk7XG4gICAgICAgIGlmIChyZXN1bHRbMF0pIHtcbiAgICAgICAgICAgIHRocm93IHJlc3VsdFswXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRbMV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSB2YWx1ZSBwYXNzZXMgYSBzdHJ1Y3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUsIHN0cnVjdCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZSh2YWx1ZSwgc3RydWN0KTtcbiAgICAgICAgcmV0dXJuICFyZXN1bHRbMF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlIGEgdmFsdWUgYWdhaW5zdCBhIHN0cnVjdCwgcmV0dXJuaW5nIGFuIGVycm9yIGlmIGludmFsaWQsIG9yIHRoZVxuICAgICAqIHZhbHVlICh3aXRoIHBvdGVudGlhbCBjb2VyY2lvbikgaWYgdmFsaWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUodmFsdWUsIHN0cnVjdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHR1cGxlcyA9IHJ1bih2YWx1ZSwgc3RydWN0LCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgdHVwbGUgPSBzaGlmdEl0ZXJhdG9yKHR1cGxlcyk7XG4gICAgICAgIGlmICh0dXBsZVswXSkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgU3RydWN0RXJyb3IodHVwbGVbMF0sIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB0IG9mIHR1cGxlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodFswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgdFswXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFtlcnJvciwgdW5kZWZpbmVkXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSB0dXBsZVsxXTtcbiAgICAgICAgICAgIHJldHVybiBbdW5kZWZpbmVkLCB2XTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzc2lnbiguLi5TdHJ1Y3RzKSB7XG4gICAgICAgIGNvbnN0IGlzVHlwZSA9IFN0cnVjdHNbMF0udHlwZSA9PT0gJ3R5cGUnO1xuICAgICAgICBjb25zdCBzY2hlbWFzID0gU3RydWN0cy5tYXAoKHMpID0+IHMuc2NoZW1hKTtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gT2JqZWN0LmFzc2lnbih7fSwgLi4uc2NoZW1hcyk7XG4gICAgICAgIHJldHVybiBpc1R5cGUgPyB0eXBlKHNjaGVtYSkgOiBvYmplY3Qoc2NoZW1hKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmaW5lIGEgbmV3IHN0cnVjdCB0eXBlIHdpdGggYSBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWZpbmUobmFtZSwgdmFsaWRhdG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RydWN0KHsgdHlwZTogbmFtZSwgc2NoZW1hOiBudWxsLCB2YWxpZGF0b3IgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBzdHJ1Y3QgYmFzZWQgb24gYW4gZXhpc3Rpbmcgc3RydWN0LCBidXQgdGhlIHZhbHVlIGlzIGFsbG93ZWQgdG9cbiAgICAgKiBiZSBgdW5kZWZpbmVkYC4gYGxvZ2Agd2lsbCBiZSBjYWxsZWQgaWYgdGhlIHZhbHVlIGlzIG5vdCBgdW5kZWZpbmVkYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZXByZWNhdGVkKHN0cnVjdCwgbG9nKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgICAgIC4uLnN0cnVjdCxcbiAgICAgICAgICAgIHJlZmluZXI6ICh2YWx1ZSwgY3R4KSA9PiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpLFxuICAgICAgICAgICAgdmFsaWRhdG9yKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZyh2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHN0cnVjdCB3aXRoIGR5bmFtaWMgdmFsaWRhdGlvbiBsb2dpYy5cbiAgICAgKlxuICAgICAqIFRoZSBjYWxsYmFjayB3aWxsIHJlY2VpdmUgdGhlIHZhbHVlIGN1cnJlbnRseSBiZWluZyB2YWxpZGF0ZWQsIGFuZCBtdXN0XG4gICAgICogcmV0dXJuIGEgc3RydWN0IG9iamVjdCB0byB2YWxpZGF0ZSBpdCB3aXRoLiBUaGlzIGNhbiBiZSB1c2VmdWwgdG8gbW9kZWxcbiAgICAgKiB2YWxpZGF0aW9uIGxvZ2ljIHRoYXQgY2hhbmdlcyBiYXNlZCBvbiBpdHMgaW5wdXQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHluYW1pYyhmbikge1xuICAgICAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgICAgICB0eXBlOiAnZHluYW1pYycsXG4gICAgICAgICAgICBzY2hlbWE6IG51bGwsXG4gICAgICAgICAgICAqZW50cmllcyh2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RydWN0ID0gZm4odmFsdWUsIGN0eCk7XG4gICAgICAgICAgICAgICAgeWllbGQqIHN0cnVjdC5lbnRyaWVzKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRvcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RydWN0ID0gZm4odmFsdWUsIGN0eCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29lcmNlcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RydWN0ID0gZm4odmFsdWUsIGN0eCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cnVjdC5jb2VyY2VyKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlZmluZXIodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0cnVjdCA9IGZuKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBzdHJ1Y3Qgd2l0aCBsYXppbHkgZXZhbHVhdGVkIHZhbGlkYXRpb24gbG9naWMuXG4gICAgICpcbiAgICAgKiBUaGUgZmlyc3QgdGltZSB2YWxpZGF0aW9uIGlzIHJ1biB3aXRoIHRoZSBzdHJ1Y3QsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZFxuICAgICAqIGFuZCBtdXN0IHJldHVybiBhIHN0cnVjdCBvYmplY3QgdG8gdXNlLiBUaGlzIGlzIHVzZWZ1bCBmb3IgY2FzZXMgd2hlcmUgeW91XG4gICAgICogd2FudCB0byBoYXZlIHNlbGYtcmVmZXJlbnRpYWwgc3RydWN0cyBmb3IgbmVzdGVkIGRhdGEgc3RydWN0dXJlcyB0byBhdm9pZCBhXG4gICAgICogY2lyY3VsYXIgZGVmaW5pdGlvbiBwcm9ibGVtLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhenkoZm4pIHtcbiAgICAgICAgbGV0IHN0cnVjdDtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICAgICAgdHlwZTogJ2xhenknLFxuICAgICAgICAgICAgc2NoZW1hOiBudWxsLFxuICAgICAgICAgICAgKmVudHJpZXModmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgICAgIHN0cnVjdCA/PyAoc3RydWN0ID0gZm4oKSk7XG4gICAgICAgICAgICAgICAgeWllbGQqIHN0cnVjdC5lbnRyaWVzKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRvcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICAgICAgc3RydWN0ID8/IChzdHJ1Y3QgPSBmbigpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RydWN0LnZhbGlkYXRvcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb2VyY2VyKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgICAgICBzdHJ1Y3QgPz8gKHN0cnVjdCA9IGZuKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJ1Y3QuY29lcmNlcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWZpbmVyKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgICAgICBzdHJ1Y3QgPz8gKHN0cnVjdCA9IGZuKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgc3RydWN0IGJhc2VkIG9uIGFuIGV4aXN0aW5nIG9iamVjdCBzdHJ1Y3QsIGJ1dCBleGNsdWRpbmdcbiAgICAgKiBzcGVjaWZpYyBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogTGlrZSBUeXBlU2NyaXB0J3MgYE9taXRgIHV0aWxpdHkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gb21pdChzdHJ1Y3QsIGtleXMpIHtcbiAgICAgICAgY29uc3QgeyBzY2hlbWEgfSA9IHN0cnVjdDtcbiAgICAgICAgY29uc3Qgc3Vic2NoZW1hID0geyAuLi5zY2hlbWEgfTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICAgICAgZGVsZXRlIHN1YnNjaGVtYVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoc3RydWN0LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3R5cGUnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlKHN1YnNjaGVtYSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Qoc3Vic2NoZW1hKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgc3RydWN0IGJhc2VkIG9uIGFuIGV4aXN0aW5nIG9iamVjdCBzdHJ1Y3QsIGJ1dCB3aXRoIGFsbCBvZiBpdHNcbiAgICAgKiBwcm9wZXJ0aWVzIGFsbG93ZWQgdG8gYmUgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBMaWtlIFR5cGVTY3JpcHQncyBgUGFydGlhbGAgdXRpbGl0eS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJ0aWFsKHN0cnVjdCkge1xuICAgICAgICBjb25zdCBpc1N0cnVjdCA9IHN0cnVjdCBpbnN0YW5jZW9mIFN0cnVjdDtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gaXNTdHJ1Y3QgPyB7IC4uLnN0cnVjdC5zY2hlbWEgfSA6IHsgLi4uc3RydWN0IH07XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgICAgICAgICAgc2NoZW1hW2tleV0gPSBvcHRpb25hbChzY2hlbWFba2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RydWN0ICYmIHN0cnVjdC50eXBlID09PSAndHlwZScpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlKHNjaGVtYSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdChzY2hlbWEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgc3RydWN0IGJhc2VkIG9uIGFuIGV4aXN0aW5nIG9iamVjdCBzdHJ1Y3QsIGJ1dCBvbmx5IGluY2x1ZGluZ1xuICAgICAqIHNwZWNpZmljIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBMaWtlIFR5cGVTY3JpcHQncyBgUGlja2AgdXRpbGl0eS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwaWNrKHN0cnVjdCwga2V5cykge1xuICAgICAgICBjb25zdCB7IHNjaGVtYSB9ID0gc3RydWN0O1xuICAgICAgICBjb25zdCBzdWJzY2hlbWEgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICAgICAgc3Vic2NoZW1hW2tleV0gPSBzY2hlbWFba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHN0cnVjdC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICd0eXBlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZShzdWJzY2hlbWEpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0KHN1YnNjaGVtYSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmaW5lIGEgbmV3IHN0cnVjdCB0eXBlIHdpdGggYSBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIFRoaXMgZnVuY3Rpb24gaGFzIGJlZW4gcmVuYW1lZCB0byBgZGVmaW5lYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHJ1Y3QobmFtZSwgdmFsaWRhdG9yKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybignc3VwZXJzdHJ1Y3RAMC4xMSAtIFRoZSBgc3RydWN0YCBoZWxwZXIgaGFzIGJlZW4gcmVuYW1lZCB0byBgZGVmaW5lYC4nKTtcbiAgICAgICAgcmV0dXJuIGRlZmluZShuYW1lLCB2YWxpZGF0b3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IGFueSB2YWx1ZSBwYXNzZXMgdmFsaWRhdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhbnkoKSB7XG4gICAgICAgIHJldHVybiBkZWZpbmUoJ2FueScsICgpID0+IHRydWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhcnJheShFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICAgICAgICBzY2hlbWE6IEVsZW1lbnQsXG4gICAgICAgICAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChFbGVtZW50ICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2ksIHZdIG9mIHZhbHVlLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgW2ksIHYsIEVsZW1lbnRdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvZXJjZXIodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5zbGljZSgpIDogdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fFxuICAgICAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYW4gYXJyYXkgdmFsdWUsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIGJpZ2ludC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiaWdpbnQoKSB7XG4gICAgICAgIHJldHVybiBkZWZpbmUoJ2JpZ2ludCcsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCc7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgYm9vbGVhbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBib29sZWFuKCkge1xuICAgICAgICByZXR1cm4gZGVmaW5lKCdib29sZWFuJywgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgdmFsaWQgYERhdGVgLlxuICAgICAqXG4gICAgICogTm90ZTogdGhpcyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgdmFsdWUgaXMgKm5vdCogYW4gaW52YWxpZCBgRGF0ZWAgb2JqZWN0LFxuICAgICAqIHdoaWNoIGNhbiBvY2N1ciB3aGVuIHBhcnNpbmcgYSBkYXRlIGZhaWxzIGJ1dCBzdGlsbCByZXR1cm5zIGEgYERhdGVgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRhdGUoKSB7XG4gICAgICAgIHJldHVybiBkZWZpbmUoJ2RhdGUnLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSAmJiAhaXNOYU4odmFsdWUuZ2V0VGltZSgpKSkgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYSB2YWxpZCBcXGBEYXRlXFxgIG9iamVjdCwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVudW1zKHZhbHVlcykge1xuICAgICAgICBjb25zdCBzY2hlbWEgPSB7fTtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSB2YWx1ZXMubWFwKCh2KSA9PiBwcmludCh2KSkuam9pbigpO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgICAgIHNjaGVtYVtrZXldID0ga2V5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgICAgIHR5cGU6ICdlbnVtcycsXG4gICAgICAgICAgICBzY2hlbWEsXG4gICAgICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHZhbHVlcy5pbmNsdWRlcyh2YWx1ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgYEV4cGVjdGVkIG9uZSBvZiBcXGAke2Rlc2NyaXB0aW9ufVxcYCwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuYygpIHtcbiAgICAgICAgcmV0dXJuIGRlZmluZSgnZnVuYycsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYSBmdW5jdGlvbiwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYW4gaW5zdGFuY2Ugb2YgYSBzcGVjaWZpYyBjbGFzcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnN0YW5jZShDbGFzcykge1xuICAgICAgICByZXR1cm4gZGVmaW5lKCdpbnN0YW5jZScsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSBpbnN0YW5jZW9mIENsYXNzIHx8XG4gICAgICAgICAgICAgICAgYEV4cGVjdGVkIGEgXFxgJHtDbGFzcy5uYW1lfVxcYCBpbnN0YW5jZSwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYW4gaW50ZWdlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnRlZ2VyKCkge1xuICAgICAgICByZXR1cm4gZGVmaW5lKCdpbnRlZ2VyJywgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICFpc05hTih2YWx1ZSkgJiYgTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkpIHx8XG4gICAgICAgICAgICAgICAgYEV4cGVjdGVkIGFuIGludGVnZXIsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmUgdGhhdCBhIHZhbHVlIG1hdGNoZXMgYWxsIG9mIGEgc2V0IG9mIHR5cGVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludGVyc2VjdGlvbihTdHJ1Y3RzKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgICAgIHR5cGU6ICdpbnRlcnNlY3Rpb24nLFxuICAgICAgICAgICAgc2NoZW1hOiBudWxsLFxuICAgICAgICAgICAgKmVudHJpZXModmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgUyBvZiBTdHJ1Y3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkKiBTLmVudHJpZXModmFsdWUsIGN0eCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICp2YWxpZGF0b3IodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgUyBvZiBTdHJ1Y3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkKiBTLnZhbGlkYXRvcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKnJlZmluZXIodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgUyBvZiBTdHJ1Y3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkKiBTLnJlZmluZXIodmFsdWUsIGN0eCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxpdGVyYWwoY29uc3RhbnQpIHtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBwcmludChjb25zdGFudCk7XG4gICAgICAgIGNvbnN0IHQgPSB0eXBlb2YgY29uc3RhbnQ7XG4gICAgICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgICAgIHR5cGU6ICdsaXRlcmFsJyxcbiAgICAgICAgICAgIHNjaGVtYTogdCA9PT0gJ3N0cmluZycgfHwgdCA9PT0gJ251bWJlcicgfHwgdCA9PT0gJ2Jvb2xlYW4nID8gY29uc3RhbnQgOiBudWxsLFxuICAgICAgICAgICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSA9PT0gY29uc3RhbnQgfHxcbiAgICAgICAgICAgICAgICAgICAgYEV4cGVjdGVkIHRoZSBsaXRlcmFsIFxcYCR7ZGVzY3JpcHRpb259XFxgLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcChLZXksIFZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgICAgIHR5cGU6ICdtYXAnLFxuICAgICAgICAgICAgc2NoZW1hOiBudWxsLFxuICAgICAgICAgICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoS2V5ICYmIFZhbHVlICYmIHZhbHVlIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIHZhbHVlLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgW2ssIGssIEtleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBbaywgdiwgVmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvZXJjZXIodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBNYXAgPyBuZXcgTWFwKHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodmFsdWUgaW5zdGFuY2VvZiBNYXAgfHxcbiAgICAgICAgICAgICAgICAgICAgYEV4cGVjdGVkIGEgXFxgTWFwXFxgIG9iamVjdCwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmUgdGhhdCBubyB2YWx1ZSBldmVyIHBhc3NlcyB2YWxpZGF0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5ldmVyKCkge1xuICAgICAgICByZXR1cm4gZGVmaW5lKCduZXZlcicsICgpID0+IGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXVnbWVudCBhbiBleGlzdGluZyBzdHJ1Y3QgdG8gYWxsb3cgYG51bGxgIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBudWxsYWJsZShzdHJ1Y3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICAgICAgLi4uc3RydWN0LFxuICAgICAgICAgICAgdmFsaWRhdG9yOiAodmFsdWUsIGN0eCkgPT4gdmFsdWUgPT09IG51bGwgfHwgc3RydWN0LnZhbGlkYXRvcih2YWx1ZSwgY3R4KSxcbiAgICAgICAgICAgIHJlZmluZXI6ICh2YWx1ZSwgY3R4KSA9PiB2YWx1ZSA9PT0gbnVsbCB8fCBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBudW1iZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbnVtYmVyKCkge1xuICAgICAgICByZXR1cm4gZGVmaW5lKCdudW1iZXInLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbHVlKSkgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYSBudW1iZXIsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvYmplY3Qoc2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IGtub3ducyA9IHNjaGVtYSA/IE9iamVjdC5rZXlzKHNjaGVtYSkgOiBbXTtcbiAgICAgICAgY29uc3QgTmV2ZXIgPSBuZXZlcigpO1xuICAgICAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgICAgIHNjaGVtYTogc2NoZW1hID8gc2NoZW1hIDogbnVsbCxcbiAgICAgICAgICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtYSAmJiBpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdW5rbm93bnMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtub3ducykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5rbm93bnMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBba2V5LCB2YWx1ZVtrZXldLCBzY2hlbWFba2V5XV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdW5rbm93bnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIFtrZXksIHZhbHVlW2tleV0sIE5ldmVyXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGlzT2JqZWN0KHZhbHVlKSB8fCBgRXhwZWN0ZWQgYW4gb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvZXJjZXIodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpID8geyAuLi52YWx1ZSB9IDogdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXVnbWVudCBhIHN0cnVjdCB0byBhbGxvdyBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gb3B0aW9uYWwoc3RydWN0KSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgICAgIC4uLnN0cnVjdCxcbiAgICAgICAgICAgIHZhbGlkYXRvcjogKHZhbHVlLCBjdHgpID0+IHZhbHVlID09PSB1bmRlZmluZWQgfHwgc3RydWN0LnZhbGlkYXRvcih2YWx1ZSwgY3R4KSxcbiAgICAgICAgICAgIHJlZmluZXI6ICh2YWx1ZSwgY3R4KSA9PiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBrZXlzIGFuZCB2YWx1ZXMgb2Ygc3BlY2lmaWMgdHlwZXMsIGJ1dFxuICAgICAqIHdpdGhvdXQgZW5zdXJpbmcgYW55IHNwZWNpZmljIHNoYXBlIG9mIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBMaWtlIFR5cGVTY3JpcHQncyBgUmVjb3JkYCB1dGlsaXR5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlY29yZChLZXksIFZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgICAgIHR5cGU6ICdyZWNvcmQnLFxuICAgICAgICAgICAgc2NoZW1hOiBudWxsLFxuICAgICAgICAgICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgayBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IHZhbHVlW2tdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgW2ssIGssIEtleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBbaywgdiwgVmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoaXNPYmplY3QodmFsdWUpIHx8IGBFeHBlY3RlZCBhbiBvYmplY3QsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIGBSZWdFeHBgLlxuICAgICAqXG4gICAgICogTm90ZTogdGhpcyBkb2VzIG5vdCB0ZXN0IHRoZSB2YWx1ZSBhZ2FpbnN0IHRoZSByZWd1bGFyIGV4cHJlc3Npb24hIEZvciB0aGF0XG4gICAgICogeW91IG5lZWQgdG8gdXNlIHRoZSBgcGF0dGVybigpYCByZWZpbmVtZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZ2V4cCgpIHtcbiAgICAgICAgcmV0dXJuIGRlZmluZSgncmVnZXhwJywgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBSZWdFeHA7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXQoRWxlbWVudCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgICAgICB0eXBlOiAnc2V0JyxcbiAgICAgICAgICAgIHNjaGVtYTogbnVsbCxcbiAgICAgICAgICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKEVsZW1lbnQgJiYgdmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBbdiwgdiwgRWxlbWVudF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFNldCA/IG5ldyBTZXQodmFsdWUpIDogdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSBpbnN0YW5jZW9mIFNldCB8fFxuICAgICAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYSBcXGBTZXRcXGAgb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBzdHJpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gZGVmaW5lKCdzdHJpbmcnLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBhIHN0cmluZywgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSB0dXBsZSBvZiBhIHNwZWNpZmljIGxlbmd0aCwgYW5kIHRoYXQgZWFjaCBvZiBpdHNcbiAgICAgKiBlbGVtZW50cyBpcyBvZiBhIHNwZWNpZmljIHR5cGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHVwbGUoU3RydWN0cykge1xuICAgICAgICBjb25zdCBOZXZlciA9IG5ldmVyKCk7XG4gICAgICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgICAgIHR5cGU6ICd0dXBsZScsXG4gICAgICAgICAgICBzY2hlbWE6IG51bGwsXG4gICAgICAgICAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1heChTdHJ1Y3RzLmxlbmd0aCwgdmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgW2ksIHZhbHVlW2ldLCBTdHJ1Y3RzW2ldIHx8IE5ldmVyXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBhbiBhcnJheSwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGhhcyBhIHNldCBvZiBrbm93biBwcm9wZXJ0aWVzIG9mIHNwZWNpZmljIHR5cGVzLlxuICAgICAqXG4gICAgICogTm90ZTogVW5yZWNvZ25pemVkIHByb3BlcnRpZXMgYXJlIGFsbG93ZWQgYW5kIHVudG91Y2hlZC4gVGhpcyBpcyBzaW1pbGFyIHRvXG4gICAgICogaG93IFR5cGVTY3JpcHQncyBzdHJ1Y3R1cmFsIHR5cGluZyB3b3Jrcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0eXBlKHNjaGVtYSkge1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc2NoZW1hKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICAgICAgdHlwZTogJ3R5cGUnLFxuICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgayBvZiBrZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBbaywgdmFsdWVba10sIHNjaGVtYVtrXV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChpc09iamVjdCh2YWx1ZSkgfHwgYEV4cGVjdGVkIGFuIG9iamVjdCwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb2VyY2VyKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSA/IHsgLi4udmFsdWUgfSA6IHZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgbWF0Y2hlcyBvbmUgb2YgYSBzZXQgb2YgdHlwZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pb24oU3RydWN0cykge1xuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IFN0cnVjdHMubWFwKChzKSA9PiBzLnR5cGUpLmpvaW4oJyB8ICcpO1xuICAgICAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgICAgICB0eXBlOiAndW5pb24nLFxuICAgICAgICAgICAgc2NoZW1hOiBudWxsLFxuICAgICAgICAgICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgUyBvZiBTdHJ1Y3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtlcnJvciwgY29lcmNlZF0gPSBTLnZhbGlkYXRlKHZhbHVlLCB7IGNvZXJjZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvZXJjZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRvcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmFpbHVyZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFMgb2YgU3RydWN0cykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbLi4udHVwbGVzXSA9IHJ1bih2YWx1ZSwgUywgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW2ZpcnN0XSA9IHR1cGxlcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaXJzdFswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbZmFpbHVyZV0gb2YgdHVwbGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbHVyZXMucHVzaChmYWlsdXJlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgYEV4cGVjdGVkIHRoZSB2YWx1ZSB0byBzYXRpc2Z5IGEgdW5pb24gb2YgXFxgJHtkZXNjcmlwdGlvbn1cXGAsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCxcbiAgICAgICAgICAgICAgICAgICAgLi4uZmFpbHVyZXMsXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmUgdGhhdCBhbnkgdmFsdWUgcGFzc2VzIHZhbGlkYXRpb24sIHdpdGhvdXQgd2lkZW5pbmcgaXRzIHR5cGUgdG8gYGFueWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5rbm93bigpIHtcbiAgICAgICAgcmV0dXJuIGRlZmluZSgndW5rbm93bicsICgpID0+IHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEF1Z21lbnQgYSBgU3RydWN0YCB0byBhZGQgYW4gYWRkaXRpb25hbCBjb2VyY2lvbiBzdGVwIHRvIGl0cyBpbnB1dC5cbiAgICAgKlxuICAgICAqIFRoaXMgYWxsb3dzIHlvdSB0byB0cmFuc2Zvcm0gaW5wdXQgZGF0YSBiZWZvcmUgdmFsaWRhdGluZyBpdCwgdG8gaW5jcmVhc2UgdGhlXG4gICAgICogbGlrZWxpaG9vZCB0aGF0IGl0IHBhc3NlcyB2YWxpZGF0aW9u4oCUZm9yIGV4YW1wbGUgZm9yIGRlZmF1bHQgdmFsdWVzLCBwYXJzaW5nXG4gICAgICogZGlmZmVyZW50IGZvcm1hdHMsIGV0Yy5cbiAgICAgKlxuICAgICAqIE5vdGU6IFlvdSBtdXN0IHVzZSBgY3JlYXRlKHZhbHVlLCBTdHJ1Y3QpYCBvbiB0aGUgdmFsdWUgdG8gaGF2ZSB0aGUgY29lcmNpb25cbiAgICAgKiB0YWtlIGVmZmVjdCEgVXNpbmcgc2ltcGx5IGBhc3NlcnQoKWAgb3IgYGlzKClgIHdpbGwgbm90IHVzZSBjb2VyY2lvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb2VyY2Uoc3RydWN0LCBjb25kaXRpb24sIGNvZXJjZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICAgICAgLi4uc3RydWN0LFxuICAgICAgICAgICAgY29lcmNlcjogKHZhbHVlLCBjdHgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXModmFsdWUsIGNvbmRpdGlvbilcbiAgICAgICAgICAgICAgICAgICAgPyBzdHJ1Y3QuY29lcmNlcihjb2VyY2VyKHZhbHVlLCBjdHgpLCBjdHgpXG4gICAgICAgICAgICAgICAgICAgIDogc3RydWN0LmNvZXJjZXIodmFsdWUsIGN0eCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXVnbWVudCBhIHN0cnVjdCB0byByZXBsYWNlIGB1bmRlZmluZWRgIHZhbHVlcyB3aXRoIGEgZGVmYXVsdC5cbiAgICAgKlxuICAgICAqIE5vdGU6IFlvdSBtdXN0IHVzZSBgY3JlYXRlKHZhbHVlLCBTdHJ1Y3QpYCBvbiB0aGUgdmFsdWUgdG8gaGF2ZSB0aGUgY29lcmNpb25cbiAgICAgKiB0YWtlIGVmZmVjdCEgVXNpbmcgc2ltcGx5IGBhc3NlcnQoKWAgb3IgYGlzKClgIHdpbGwgbm90IHVzZSBjb2VyY2lvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWZhdWx0ZWQoc3RydWN0LCBmYWxsYmFjaywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBjb2VyY2Uoc3RydWN0LCB1bmtub3duKCksICh4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmID0gdHlwZW9mIGZhbGxiYWNrID09PSAnZnVuY3Rpb24nID8gZmFsbGJhY2soKSA6IGZhbGxiYWNrO1xuICAgICAgICAgICAgaWYgKHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnN0cmljdCAmJiBpc1BsYWluT2JqZWN0KHgpICYmIGlzUGxhaW5PYmplY3QoZikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXQgPSB7IC4uLnggfTtcbiAgICAgICAgICAgICAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldFtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldFtrZXldID0gZltrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF1Z21lbnQgYSBzdHJ1Y3QgdG8gdHJpbSBzdHJpbmcgaW5wdXRzLlxuICAgICAqXG4gICAgICogTm90ZTogWW91IG11c3QgdXNlIGBjcmVhdGUodmFsdWUsIFN0cnVjdClgIG9uIHRoZSB2YWx1ZSB0byBoYXZlIHRoZSBjb2VyY2lvblxuICAgICAqIHRha2UgZWZmZWN0ISBVc2luZyBzaW1wbHkgYGFzc2VydCgpYCBvciBgaXMoKWAgd2lsbCBub3QgdXNlIGNvZXJjaW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW1tZWQoc3RydWN0KSB7XG4gICAgICAgIHJldHVybiBjb2VyY2Uoc3RydWN0LCBzdHJpbmcoKSwgKHgpID0+IHgudHJpbSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbnN1cmUgdGhhdCBhIHN0cmluZywgYXJyYXksIG1hcCwgb3Igc2V0IGlzIGVtcHR5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVtcHR5KHN0cnVjdCkge1xuICAgICAgICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ2VtcHR5JywgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzaXplID0gZ2V0U2l6ZSh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gKHNpemUgPT09IDAgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYW4gZW1wdHkgJHtzdHJ1Y3QudHlwZX0gYnV0IHJlY2VpdmVkIG9uZSB3aXRoIGEgc2l6ZSBvZiBcXGAke3NpemV9XFxgYCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRTaXplKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCB8fCB2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnNpemU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IGEgbnVtYmVyIG9yIGRhdGUgaXMgYmVsb3cgYSB0aHJlc2hvbGQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF4KHN0cnVjdCwgdGhyZXNob2xkLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgeyBleGNsdXNpdmUgfSA9IG9wdGlvbnM7XG4gICAgICAgIHJldHVybiByZWZpbmUoc3RydWN0LCAnbWF4JywgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZXhjbHVzaXZlXG4gICAgICAgICAgICAgICAgPyB2YWx1ZSA8IHRocmVzaG9sZFxuICAgICAgICAgICAgICAgIDogdmFsdWUgPD0gdGhyZXNob2xkIHx8XG4gICAgICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBhICR7c3RydWN0LnR5cGV9IGxlc3MgdGhhbiAke2V4Y2x1c2l2ZSA/ICcnIDogJ29yIGVxdWFsIHRvICd9JHt0aHJlc2hvbGR9IGJ1dCByZWNlaXZlZCBcXGAke3ZhbHVlfVxcYGA7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmUgdGhhdCBhIG51bWJlciBvciBkYXRlIGlzIGFib3ZlIGEgdGhyZXNob2xkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1pbihzdHJ1Y3QsIHRocmVzaG9sZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgZXhjbHVzaXZlIH0gPSBvcHRpb25zO1xuICAgICAgICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ21pbicsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGV4Y2x1c2l2ZVxuICAgICAgICAgICAgICAgID8gdmFsdWUgPiB0aHJlc2hvbGRcbiAgICAgICAgICAgICAgICA6IHZhbHVlID49IHRocmVzaG9sZCB8fFxuICAgICAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYSAke3N0cnVjdC50eXBlfSBncmVhdGVyIHRoYW4gJHtleGNsdXNpdmUgPyAnJyA6ICdvciBlcXVhbCB0byAnfSR7dGhyZXNob2xkfSBidXQgcmVjZWl2ZWQgXFxgJHt2YWx1ZX1cXGBgO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlIHRoYXQgYSBzdHJpbmcsIGFycmF5LCBtYXAgb3Igc2V0IGlzIG5vdCBlbXB0eS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub25lbXB0eShzdHJ1Y3QpIHtcbiAgICAgICAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdub25lbXB0eScsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IGdldFNpemUodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIChzaXplID4gMCB8fCBgRXhwZWN0ZWQgYSBub25lbXB0eSAke3N0cnVjdC50eXBlfSBidXQgcmVjZWl2ZWQgYW4gZW1wdHkgb25lYCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmUgdGhhdCBhIHN0cmluZyBtYXRjaGVzIGEgcmVndWxhciBleHByZXNzaW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhdHRlcm4oc3RydWN0LCByZWdleHApIHtcbiAgICAgICAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdwYXR0ZXJuJywgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKHJlZ2V4cC50ZXN0KHZhbHVlKSB8fFxuICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBhICR7c3RydWN0LnR5cGV9IG1hdGNoaW5nIFxcYC8ke3JlZ2V4cC5zb3VyY2V9L1xcYCBidXQgcmVjZWl2ZWQgXCIke3ZhbHVlfVwiYCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmUgdGhhdCBhIHN0cmluZywgYXJyYXksIG51bWJlciwgZGF0ZSwgbWFwLCBvciBzZXQgaGFzIGEgc2l6ZSAob3IgbGVuZ3RoLCBvciB0aW1lKSBiZXR3ZWVuIGBtaW5gIGFuZCBgbWF4YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaXplKHN0cnVjdCwgbWluLCBtYXggPSBtaW4pIHtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWQgPSBgRXhwZWN0ZWQgYSAke3N0cnVjdC50eXBlfWA7XG4gICAgICAgIGNvbnN0IG9mID0gbWluID09PSBtYXggPyBgb2YgXFxgJHttaW59XFxgYCA6IGBiZXR3ZWVuIFxcYCR7bWlufVxcYCBhbmQgXFxgJHttYXh9XFxgYDtcbiAgICAgICAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdzaXplJywgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKChtaW4gPD0gdmFsdWUgJiYgdmFsdWUgPD0gbWF4KSB8fFxuICAgICAgICAgICAgICAgICAgICBgJHtleHBlY3RlZH0gJHtvZn0gYnV0IHJlY2VpdmVkIFxcYCR7dmFsdWV9XFxgYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCB8fCB2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2l6ZSB9ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgobWluIDw9IHNpemUgJiYgc2l6ZSA8PSBtYXgpIHx8XG4gICAgICAgICAgICAgICAgICAgIGAke2V4cGVjdGVkfSB3aXRoIGEgc2l6ZSAke29mfSBidXQgcmVjZWl2ZWQgb25lIHdpdGggYSBzaXplIG9mIFxcYCR7c2l6ZX1cXGBgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKChtaW4gPD0gbGVuZ3RoICYmIGxlbmd0aCA8PSBtYXgpIHx8XG4gICAgICAgICAgICAgICAgICAgIGAke2V4cGVjdGVkfSB3aXRoIGEgbGVuZ3RoICR7b2Z9IGJ1dCByZWNlaXZlZCBvbmUgd2l0aCBhIGxlbmd0aCBvZiBcXGAke2xlbmd0aH1cXGBgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF1Z21lbnQgYSBgU3RydWN0YCB0byBhZGQgYW4gYWRkaXRpb25hbCByZWZpbmVtZW50IHRvIHRoZSB2YWxpZGF0aW9uLlxuICAgICAqXG4gICAgICogVGhlIHJlZmluZXIgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byByZWNlaXZlIGEgdmFsdWUgb2YgdGhlIHN0cnVjdCdzIHR5cGUsXG4gICAgICogYmVjYXVzZSB0aGUgc3RydWN0J3MgZXhpc3RpbmcgdmFsaWRhdGlvbiB3aWxsIGFscmVhZHkgaGF2ZSBwYXNzZWQuIFRoaXNcbiAgICAgKiBhbGxvd3MgeW91IHRvIGxheWVyIGFkZGl0aW9uYWwgdmFsaWRhdGlvbiBvbiB0b3Agb2YgZXhpc3Rpbmcgc3RydWN0cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWZpbmUoc3RydWN0LCBuYW1lLCByZWZpbmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgICAgIC4uLnN0cnVjdCxcbiAgICAgICAgICAgICpyZWZpbmVyKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCogc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVmaW5lcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgICAgICBjb25zdCBmYWlsdXJlcyA9IHRvRmFpbHVyZXMocmVzdWx0LCBjdHgsIHN0cnVjdCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZmFpbHVyZSBvZiBmYWlsdXJlcykge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB7IC4uLmZhaWx1cmUsIHJlZmluZW1lbnQ6IG5hbWUgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBleHBvcnRzLlN0cnVjdCA9IFN0cnVjdDtcbiAgICBleHBvcnRzLlN0cnVjdEVycm9yID0gU3RydWN0RXJyb3I7XG4gICAgZXhwb3J0cy5hbnkgPSBhbnk7XG4gICAgZXhwb3J0cy5hcnJheSA9IGFycmF5O1xuICAgIGV4cG9ydHMuYXNzZXJ0ID0gYXNzZXJ0O1xuICAgIGV4cG9ydHMuYXNzaWduID0gYXNzaWduO1xuICAgIGV4cG9ydHMuYmlnaW50ID0gYmlnaW50O1xuICAgIGV4cG9ydHMuYm9vbGVhbiA9IGJvb2xlYW47XG4gICAgZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2U7XG4gICAgZXhwb3J0cy5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZXhwb3J0cy5kYXRlID0gZGF0ZTtcbiAgICBleHBvcnRzLmRlZmF1bHRlZCA9IGRlZmF1bHRlZDtcbiAgICBleHBvcnRzLmRlZmluZSA9IGRlZmluZTtcbiAgICBleHBvcnRzLmRlcHJlY2F0ZWQgPSBkZXByZWNhdGVkO1xuICAgIGV4cG9ydHMuZHluYW1pYyA9IGR5bmFtaWM7XG4gICAgZXhwb3J0cy5lbXB0eSA9IGVtcHR5O1xuICAgIGV4cG9ydHMuZW51bXMgPSBlbnVtcztcbiAgICBleHBvcnRzLmZ1bmMgPSBmdW5jO1xuICAgIGV4cG9ydHMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICBleHBvcnRzLmludGVnZXIgPSBpbnRlZ2VyO1xuICAgIGV4cG9ydHMuaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uO1xuICAgIGV4cG9ydHMuaXMgPSBpcztcbiAgICBleHBvcnRzLmxhenkgPSBsYXp5O1xuICAgIGV4cG9ydHMubGl0ZXJhbCA9IGxpdGVyYWw7XG4gICAgZXhwb3J0cy5tYXAgPSBtYXA7XG4gICAgZXhwb3J0cy5tYXNrID0gbWFzaztcbiAgICBleHBvcnRzLm1heCA9IG1heDtcbiAgICBleHBvcnRzLm1pbiA9IG1pbjtcbiAgICBleHBvcnRzLm5ldmVyID0gbmV2ZXI7XG4gICAgZXhwb3J0cy5ub25lbXB0eSA9IG5vbmVtcHR5O1xuICAgIGV4cG9ydHMubnVsbGFibGUgPSBudWxsYWJsZTtcbiAgICBleHBvcnRzLm51bWJlciA9IG51bWJlcjtcbiAgICBleHBvcnRzLm9iamVjdCA9IG9iamVjdDtcbiAgICBleHBvcnRzLm9taXQgPSBvbWl0O1xuICAgIGV4cG9ydHMub3B0aW9uYWwgPSBvcHRpb25hbDtcbiAgICBleHBvcnRzLnBhcnRpYWwgPSBwYXJ0aWFsO1xuICAgIGV4cG9ydHMucGF0dGVybiA9IHBhdHRlcm47XG4gICAgZXhwb3J0cy5waWNrID0gcGljaztcbiAgICBleHBvcnRzLnJlY29yZCA9IHJlY29yZDtcbiAgICBleHBvcnRzLnJlZmluZSA9IHJlZmluZTtcbiAgICBleHBvcnRzLnJlZ2V4cCA9IHJlZ2V4cDtcbiAgICBleHBvcnRzLnNldCA9IHNldDtcbiAgICBleHBvcnRzLnNpemUgPSBzaXplO1xuICAgIGV4cG9ydHMuc3RyaW5nID0gc3RyaW5nO1xuICAgIGV4cG9ydHMuc3RydWN0ID0gc3RydWN0O1xuICAgIGV4cG9ydHMudHJpbW1lZCA9IHRyaW1tZWQ7XG4gICAgZXhwb3J0cy50dXBsZSA9IHR1cGxlO1xuICAgIGV4cG9ydHMudHlwZSA9IHR5cGU7XG4gICAgZXhwb3J0cy51bmlvbiA9IHVuaW9uO1xuICAgIGV4cG9ydHMudW5rbm93biA9IHVua25vd247XG4gICAgZXhwb3J0cy52YWxpZGF0ZSA9IHZhbGlkYXRlO1xuXG59KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5janMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/superstruct/dist/index.cjs\n");

/***/ })

};
;